<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0" />

    <!--Description-->
    
        <meta name="description" content="传统Web交互
传统web交互是浏览器发送request，服务器收到request后把相应的信息（HTML界面信息等）返回给浏览器，呈现出来。比如：输入www.baidu.com后，发送get请求到百度服务器，百度服务器返回相应的界面给用户。这种交互叫同步交互, 并且期间处于阻塞状态。
通俗讲，既“">
    

    <!--Author-->
    
        <meta name="author" content="刘畅">
    

    <!--Open Graph Title-->
    
        <meta property="og:title" content="2. Ajax原理"/>
    

    <!--Open Graph Site Name-->
    <meta property="og:site_name" content="塔不倒，人不退"/>

    <!--Page Cover-->
    
        <meta property="og:image" content=""/>
    

    <!-- Title -->
    
    <title>2. Ajax原理 - 塔不倒，人不退</title>

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/font-awesome.min.css">
    <link rel="stylesheet" href="/css/reset.css">
    <link rel="stylesheet" href="/css/main.css">



    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- Gallery -->
    <link href="//cdn.rawgit.com/noelboss/featherlight/1.3.5/release/featherlight.min.css" type="text/css" rel="stylesheet" />

    <!-- Google Analytics -->
    


</head>

<body>

<!-- Menu -->
<!-- Navigation -->
<header class="header-background">
    <div class="logo">
        <a href="/">塔不倒，人不退</a>
    </div><!-- end logo -->

    <div id="menu_icon"></div>
    <nav>
        <ul>
            
            <li>
                <a href="/">Home</a>
            </li>
            
            <li>
                <a href="/archives">Archives</a>
            </li>
            
            <li>
                <a href="/tags">Tags</a>
            </li>
            
            <li>
                <a href="/about">About</a>
            </li>
            
        </ul>
    </nav><!-- end navigation menu -->

    <div class="footer clearfix">
        <ul class=" social clearfix">

            <li><a href="https://github.com/ChangLiuuu" target="_blank"><i
                            class="fa fa-github"></i></a>
            </li>
            <li><a href="https://www.linkedin.com/in/changliu6/" target="_blank"><i
                            class="fa fa-linkedin-square"></i></a></li>
        </ul><!-- end social -->

        <div class="rights">
            <p>计算机小硕未毕业, dota爱好者.<br>希望成为一名有趣的工程师.</p>
            <p>Author <strong>刘畅</strong></p>
        </div><!-- end rights -->
    </div><!-- end footer -->
</header><!-- end header -->

<!-- Main Content -->
<section class="main clearfix">

    <section class="top" style="background: url('/img/assets/b0.png');">
        <div class="wrapper content_header clearfix">
            

<div class="work_nav">

    <ul class="btn clearfix">
        
        <li><a class="previous disabled"></a></li>
        
        <li><a href="/" class="grid" data-title="Portfolio"></a></li>
        
        <li><a href="/2017/10/09/1-my-blog/" class="next" data-title="1. My First blog"></a></li>
        
    </ul>

</div><!-- end work_nav -->
            <h1 class="title">2. Ajax原理</h1>
        </div>
    </section><!-- end top -->

    <section class="wrapper">
        <div class="content">

            <!-- Gallery -->
            

            <!-- Content -->
            <p>传统Web交互</p>
<p>传统web交互是浏览器发送request，服务器收到request后把相应的信息（HTML界面信息等）返回给浏览器，呈现出来。比如：输入www.baidu.com后，发送get请求到百度服务器，百度服务器返回相应的界面给用户。这种交互叫同步交互, 并且期间处于阻塞状态。</p>
<p>通俗讲，既“你一来，干等着我一回”。像是一小伙正在追一个姑娘，在嘈杂的宿舍发完微信，啥都不敢干了，手机不离手，盯着屏幕等着姑娘回信息。如同用户请求完，等着服务器返回信息，等待期间什么也没法干。再碰到网速慢，界面卡个白屏就慢慢等吧。</p>
<p>Ajax的应用</p>
<p>AJAX = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）。</p>
<p>AJAX 不是新的编程语言，而是一种使用现有标准的新方法。</p>
<p>AJAX 是与服务器交换数据并更新部分网页的艺术，在不重新加载整个页面的情况下。</p>
<p>明确几个说法：1. 异步，2. XML， 3.现有标准的新方法</p>
<ol>
<li>异步</li>
</ol>
<p>异步交互颠覆传统web交互，就不是 “你一来，干等着女神回信息” 了。而是，发完微信后，让闲着没事的舍友帮忙看着手机屏幕，本人继续专心团战，吃零食，倒垃圾等。等女神回信息了，让舍友嗷一嗓，我再回过头来回微信。  既主线程是不阻塞的，代码继续执行，等请求有消息了，我再回过头处理，所以叫回调函数（callback function）。</p>
<ol>
<li>XML </li>
</ol>
<p>先和熟悉的JSON对比：</p>
<p>1.概念</p>
<p>　　·JSON</p>
<p>　　JSON（Javascript Object Notation，Javascript对象表示法）是一种轻量级的数据格式，而不是一种编程语言。它利用Javascript中某些模式来表示结构化数据，通过eval()方法，Javascript能够把这种数据格式转化为对应的js类型来使用。</p>
<p>　　.XML</p>
<p>　　XML（Extensible Markup Language，可扩展性标记语言）是一种用来交换数据的标记语言，而同样是标记语言的HTML（HyperText Markup Language，超文本标记语言）则是用来显示数据的标记语言。它允许用户自定义标签来标记数据和定义数据类型。</p>
<p>·联系</p>
<p>　　JSON和XML均是可跨平台使用的，且它们都是用于交换数据所用。后者相对而言更具有历史性，所以通用性也自然地比较抢，而且它衍生出很多其他的语言，譬如SVG、RSS等等。</p>
<p>　　但由于JSON格式简单直白，且一般是压缩形式出现，所以请求文件的大小自然缩小。因此，前端工程师们应该都不会不爱它吧。</p>
<pre><code>{
    name: &quot;cliu&quot;,
    email: {
        personal: [&quot;cliu@xxx.com&quot;, &quot;cliu@xxx.cn&quot;],
        school: &quot;cliu@school.com&quot;
    },
    learnt: [
        {
            name: &quot;CSS&quot;,
            status: 0.8
        },{
            name: &quot;jQuery&quot;,
            status: 0.5
        }
    ]
}
</code></pre><p>　　·标准的XML</p>
<p>　　上面第二个JSON的例子，如果写成差不多意思的XML，格式大致如下</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;
&lt;me&gt;
    &lt;name&gt;linji&lt;/name&gt;
    &lt;email&gt;
        &lt;personal&gt;cliu@xxx.com&lt;/personal&gt;
        &lt;personal&gt;cliu@xxx.cn&lt;/personal&gt;
        &lt;company&gt;cliu@school.com&lt;/company&gt;
    &lt;/email&gt;
    &lt;learnt&gt;
        &lt;name&gt;CSS&lt;/name&gt;
        &lt;status&gt;0.8&lt;/status&gt;
    &lt;/learnt&gt;
    &lt;learnt&gt;
        &lt;name&gt;jQuery&lt;/name&gt;
        &lt;status&gt;0.5&lt;/status&gt;
    &lt;/learnt&gt;
&lt;/me&gt;
</code></pre><p>PS:　而XML衍生出子集-SVG（Scalable Vector Graphics，可缩放矢量图形）则是一种能够生成矢量图的语言。在如今Retina显示屏的发展趋势，能够在任何时候呈现出足够清晰的图像绝对是必要的。</p>
<p>所以说，XML是一种数据格式，类似于xxxx.mxl。 很好理解，因为Ajax使用js可以很容易操纵MXL的标签和内容。（下面会说到Ajax和js的关系）</p>
<p>除了 XML File， Ajax还涉及了 XML Http，下面会说到 XMLHttpRequest :</p>
<pre><code>var xhr = window.XMLHttpRequest ? new XMLHttpRequest() : new ActiveXObject(&apos;Microsoft.XMLHTTP&apos;);//三元操作 微软浏览器比较特殊- -
</code></pre><ol>
<li>Ajax是现有标准的新方法</li>
</ol>
<p>为什么来这么一句呢。。因为Ajax确实不是什么新技术，因为Ajax核心是创建 XMLHttpRequest对象，而这个对象很早就被微软设计了，但流行起来是由Google带动的。google map 和 google suggest。google map 远近拉动地图，但map并不会不停刷新，而是很流畅的感觉，虽然各个餐厅或者道路会慢慢加载，但没有中断用户体验。 google suggest就是搜索引擎的下拉窗口的提示字，动态变化。</p>
<p>所有现代浏览器均支持 XMLHttpRequest 对象（IE5 和 IE6 使用 ActiveXObject）。XMLHttpRequest 用于在后台与服务器交换数据。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。</p>
<pre><code>Ajax是基于现有的Internet标准，并且联合使用：

1. XMLHttpRequest 对象 (异步的与服务器交换数据) 
2. 2JavaScript/DOM (信息显示/交互) 
3. CSS (给数据定义样式) 
4. XML (作为转换数据的格式) 图片描述

所以说Ajax是利用现有标准的组合，形成的新标准和新方法。
</code></pre><p>回过头来对应说下 “追女神和舍友帮忙” 的问题。</p>
<p>我叫来舍友，相当于 1. 创建XMLHttpRequest对象，这个对象和服务器先交互着，我先忙我的。等手机有消息了，根据消息 我来做出反应  2. 用返回的消息来用JS操作本地的DOM 以及 <em> 3. 变化相应CSS</em> 或  “4. 或是把 MXL格式的文件信息展示到页面上。</p>
<p>Ajax 实现</p>
<p>创建Ajax对象：</p>
<p>//IE6以上 var oAjax = new XMLHttpRequest();</p>
<p>//IE6 var oAjax =new ActiveXObject(“Microsoft.XMLHTTP”)</p>
<pre><code> //创建一个ajax对象 ie6以下
 //new ActiveXObject(&apos;Microsoft.XMLHTTP&apos;)

 var xhr = window.XMLHttpRequest ? new XMLHttpRequest() : new ActiveXObject(&apos;Microsoft.XMLHTTP&apos;);//三元操作
 /*
 var xhr = null;
 if (window.XMLHttpRequest) {
     xhr = new XMLHttpRequest();
 } else {
     xhr = new ActiveXObject(&apos;Microsoft.XMLHTTP&apos;);
 }*/

 /*try {
     xhr = new XMLHttpRequest();
 } catch (e) {
     xhr = new ActiveXObject(&apos;Microsoft.XMLHTTP&apos;);
 }
 */
//以上提供了三种方法,任选一种    
//alert( xhr.readyState );完成第一步
</code></pre><p>连接服务器</p>
<p>oAjax.open(方法,url,是否异步) &gt; 我们都知道，Ajax即“Asynchronous Javascript And XML”（异步JavaScript和XML），是指一种创建交互式网页应用的网页开发技术。所以，Ajax天生就是工作在异步模式的（异步为true，同步false）</p>
<p>同步和异步</p>
<ul>
<li>同步是指：发送方发出数据后，等接收方发回响应以后才发下一个数据包的通讯方式。</li>
<li>异步是指：发送方发出数据后，不等接收方发回响应，接着发送下个数据包的通讯方式。</li>
</ul>
<p>（简单点说：同步就是只能一件一件事的来做，而异步就是可以多件事同时进行）</p>
<p>open方法 参数 </p>
<p>1.打开方式 </p>
<p>2.地址 </p>
<p>3.是否异步 异步:非阻塞 前面的代码不会影响后面代码的执行 </p>
<p>同步:阻塞 前面的代码会影响后面代码的执行 </p>
<p>tip：那么什么时候要用到同步呢，就是后面的代码需要前面的代码完成后才能开始执行时，就要使用同步策略。</p>
<pre><code>xhr.open(&apos;get&apos;, &apos;test.txt&apos;, true);
</code></pre><p>发送请求send()</p>
<p>send 里面的参数get方法可以不填或者null；post方法填要传到后台的数据参数。</p>
<p>服务器返回内容。处理返回数据</p>
<p>详细信息见下面分析</p>
<ul>
<li>readyState : ajax工作状态 0 1 2 3 4</li>
<li>responseText : ajax请求返回的内容就被存放到这个属性下面.但是数据类型是string类型。需要使用eval来转换，然后才能使用。</li>
<li>responseXml : 返回XML格式的数据</li>
<li>on readystate change : 当readyState状态改变的时候触发这个事件</li>
<li>status : 服务器状态，http状态码</li>
<li>statusText : 状态说明</li>
</ul>
<hr>
<pre><code>xhr.onreadystatechange = function() {
    if (xhr.readyState == 4) {
        if (xhr.status == 200) {
            // 处理数据
            // alert(xhr.responseText);
            oB.innerHTML = xhr.responseText;
            /*var str = xhr.responseText;
            oB.innerHTMl = eval(str);*/
        } else {
            alert(&apos;出错了,Erro&apos; + xhr.status);
        }
    }

} 一个示例

function getDoc(){
    var xmlhttp;
    if(window.xmlhttpRequest){
        xmlhttp=new XMLHttpRequest();
    }
    else{
        xmlhttp = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);//for IE6
    }
    xmlhttp.onreadystatechange = function(){
        if(xmlhttp.readyState==4&amp;&amp;xmlhttp.status==200){
            document.getElementById(&quot;￼myId&quot;).innerHTML=xmlhttp.responseText;
        }
    }
    xmlhttp.open(&quot;￼GET&quot;, index.php,true);
    xmlhttp.send();
}

&lt;body&gt;
    &lt;button type=&quot;button&quot; onclick=&quot;getDoc()&quot;&gt;请求数据&lt;/button&gt;
&lt;/body&gt;
</code></pre><p>GET 还是 POST？</p>
<ul>
<li>与 POST 相比，GET 更简单也更快，并且在大部分情况下都能用。</li>
<li>然而，在以下情况中，请使用 POST 请求：</li>
</ul>
<p>无法使用缓存文件（更新服务器上的文件或数据库） 向服务器发送大量数据（POST 没有数据量限制） 发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠</p>
<p>接收返回信息</p>
<pre><code>oAjax.onreadystatechange = function(){  
    //当请求状态改变时要调用的事件处理器
    alert(oAjax.readystate);           
} 只要readyState属性的值发生变化时，便会触发一次readyStatechange事件。可以利用这个事件来检测每次状态变化后readyState的值。通常，我们只对readyState值为4的阶段感兴趣，因为这时所有数据都已经就绪，不过，必须在调用open()之前指定onreadystatechange事件处理程序才能确保跨浏览器兼容性。下面来看一个例子：

var xhr = createXHR();
xhr.onreadystatechange = function () {
    if (xhr.readyState == 4) {
        if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304) {
            alert(xhr.statusText);
        } else {
            alert(&quot;Request was unsuccessful: &quot; + xhr.status);
        }
    }
};
xhr.open(&quot;get&quot;, &quot;example.txt&quot;, true);
xhr.send(null);
</code></pre><p>XHR对象</p>
<p>XMLHttpRequest这个对象的属性：</p>
<p>1、 属性</p>
<ul>
<li>onreadystatechange 每次状态改变所触发事件的事件处理程序。</li>
<li>responseText 从服务器进程返回数据的字符串形式。</li>
<li>responseXML 从服务器进程返回的DOM兼容的文档数据对象。</li>
<li>status 从服务器返回的数字代码，比如常见的404（未找到）和200（已就绪）</li>
<li>status Text 伴随状态码的字符串信息</li>
</ul>
<p>2、 状态</p>
<p>当XHR对象把一个HTTP请求发送到服务器的过程中会经历几个状态，直到请求被处理，然后才接收一个回应。readyState就是XHR请求的状态属性，它本身有5个属性值：</p>
<p>0（未初始化）还没有调用open()方法 1（载入）已调用send()方法，正在发送请求 2(载入完成)send()方法完成，已收到全部响应内容 3(解析)正在解析响应内容 4（完成）响应内容解析完成，可以再客户端使用了</p>
<p>http状态码</p>
<p>1字头：消息。这一类型的状态码，代表请求已被接受，需要继续处理。 2字头：成功。这一类型的状态码，代表请求已成功被服务器接收、理解、并接受。 3字头：重定向。这类状态码代表需要客户端采取进一步的操作才能完成请求。 4字头：客户端错误。这类状态码代表了客户端看起来可能发生错误，妨碍了服务器的处理。 5字头：服务器错误。这类状态码代表了服务器在处理请求的过程中有错误或者异常状态发生</p>
<p>另附：http状态码详解</p>
<p>w3cschool HTTP 状态消息</p>
<p>4、status和statusText</p>
<p>statusText是响应返回的文本信息，仅当readyState值为3或4的时候才能使用。当readyState为其它值时视图存取statusText属性将引发异常</p>
<hr>
<p>XHR的方法</p>
<ul>
<li>abort() ： 导致当前正在执行的请求被取消</li>
<li>getAllResponseHeaders() ： 返回包含所有响应头的名称和值的单个字符串</li>
<li>getResponseHeader(name) ： 返回响应头中指定的名称和值</li>
<li>open(method,url,async,username,pwd) ： 设置HTTP方法（get或post）等</li>
<li>send(content) ： 发出带有指定主体内容的请求</li>
<li>setRequestHeader(name,value) ： 使用指定的名称和值设置请求头</li>
</ul>
<hr>
<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;
        var oAjax =oAjax();
        alert(oAjax.readyState);//弹出&quot;0&quot;
        oAjax.open(&quot;get&quot;,&quot;index.html&quot;,true);
        alert(oAjax.readyState);//弹出&quot;1&quot;
        oAjax.send(null);
        alert(oAjax.readyState);//IE下弹出4,而firefox是2
        //可以通过readystatechange事件监听
        oAjax = XHR();
        oAjax.onreadystatechange = function () {
            alert(oAjax.readyState);//Firefox下依次是1,2,3,4但最后还会再来个1
            //IE下则是1,1,3,4
        };
        oAjax.open(&quot;get&quot;,&quot;index.txt&quot;,true);
        oAjax.send(null);
&lt;/script&gt;
</code></pre><p>jQuery中的Ajax</p>
<p>$.load()方法</p>
<p>.load()方法是局部方法，因为他需要一个包含元素的jQuery对象作为前缀，而$.get()和$.post()是全局方法，无需指定某个元素，对于用途而言，.load()适合做静态文件的异步获取，而对于需要传递参数到服务器页面的，$.get()和$.post()更加合适。</p>
<pre><code>$(function () {
    $(&quot;input&quot;).click(function () {
        $.get(&apos;test.php?url=baidu.com&apos;, function (response,status,xhr) {
            $(&apos;#box&apos;).html(response);
        })
    })
});
</code></pre><p>$.post()</p>
<p>POST提交不能使用url传参。post提交可以使用字符串形式的键值对形式传参，自动转换为http消息实体传参</p>
<pre><code>$(function () {
    $(&quot;input&quot;).click(function () {
        $.post(&apos;test.php&apos;,&apos;url=baidu.com&apos;, function (response,status,xhr) {
            $(&apos;#box&apos;).html(response);
        })
    })
}); //post提交可以使用对象键值对

$(function () {
    $(&quot;input&quot;).click(function () {
        $.post(&apos;test.php&apos;,{
                url:&apos;baidu.com&apos;//post提交可以使用对象键值对
            }, function (response,status,xhr) {
            $(&apos;#box&apos;).html(response);
        })
    })
});
</code></pre><p>$.get()方法</p>
<p>$.get()方法有四个参数，前面三个参数和.load()一样，多了一个第四参数type，即服务器返回的内容格式，包括xml,json,script,html,text等，第一个参数为必选参数，后面三个为可选参数</p>
<p>$.ajax()方法</p>
<p>$.ajax()是所有Ajax方法中最底层的方法，所有其他方法都是基于$.ajax()方法的封装，这个方法只有一个参数，传递一个 各个功能键值对的对象。</p>
<p>$.ajax()方法对象参数列表</p>
<p>  参数          类型               说明<br>  url         string           发送请求的地址<br>  type        string           请求方法，默认GET<br>  timeout     Number           设置请求超时的时间<br>  data        Object或String    发送到服务器的对象，键值对字符串或对象<br>  datatype    String           返回的数据类型，比如html，XML，json等<br>  success     Function         请求成功后调用的回调函数<br>  complete    Function         请求完成后调用的回调函数<br>  error       Function         请求失败后调用的回调函数            </p>
<hr>
<pre><code>$(function () {
    $(&quot;input&quot;).click(function () {
        $.ajax({
            type : &quot;POST&quot;,
            url: &apos;test.php&apos;,
            data:{
                url: &apos;baidu.com&apos;
            },
            success : function(response,status,xhr){
                $(&apos;#box&apos;).html(response);
            }
        })
    })
});
</code></pre><p>表单序列化</p>
<p>Ajax用的最多的地方莫过于表单操作，而传统的表单操作是通过submit提交将数据传输到服务器，如果使用Ajax异步处理 的话，我们需要将每个表单元素获取才能提交，这样工作效率就大大降低</p>
<pre><code>&lt;body&gt;
&lt;form action=&quot;&quot;&gt;
    用户名: &lt;input type=&quot;text&quot; name=&quot;user&quot; /&gt;
    邮件: &lt;input type=&quot;text&quot; name=&quot;email&quot; /&gt;
    &lt;input type=&quot;button&quot; value=&quot;提交&quot;/&gt;
&lt;/form&gt;
&lt;div id=&quot;box&quot;&gt;&lt;/div&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
    $(function () {
        $(&quot;form input[type=button]&quot;).click(function () {
            $.ajax({
                type: &apos;POST&apos;,
                url: &apos;test.php&apos;,
                data: {
                    user: $(&apos;form input[name=user]&apos;).val(),
                    email: $(&quot;form input[name=email]&quot;).val(),
                },
                success: function(response){
                    $(&quot;#box&quot;).html(response);
                }
            })
        })
    });
&lt;/script&gt;
&lt;/body&gt;
</code></pre><p>表单元素特别多的情况下应采用表单序列化，即data:$(“form”).serialize();//得到的是字符串键值对，并且对url进行编码</p>
<p>serialize()方法不但可以序列化表单内的元素，还可以直接获取单选框，复选框和下拉列表框等内容</p>
<pre><code>&lt;body&gt;
&lt;form action=&quot;&quot;&gt;
    用户名: &lt;input type=&quot;text&quot; name=&quot;user&quot; /&gt;
    邮件: &lt;input type=&quot;text&quot; name=&quot;email&quot; /&gt;
    &lt;input type=&quot;button&quot; value=&quot;提交&quot;/&gt;
    &lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;男&quot;/&gt;男
    &lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;女&quot;/&gt;女
    &lt;input type=&quot;button&quot; value=&quot;submit&quot;/&gt;
&lt;/form&gt;
&lt;div id=&quot;box&quot;&gt;&lt;/div&gt;
&lt;script&gt;
    $(function () {
        $(&quot;form input[name=sex]&quot;).click(function () {
            $(&apos;#box&apos;).html(decodeURIComponent($(this).serialize()));
        })
    })
&lt;/script&gt;
&lt;/body&gt;
</code></pre><p>传统Ajax问题</p>
<p>传统的ajax有如下的问题：</p>
<p>1、可以无刷新改变页面内容，但无法改变页面URL</p>
<p>2、为了更好的可访问性，内容发生改变后，通常改变URL的hash</p>
<p>3、hash的方式不能很好的处理浏览器的前进、后退等问题</p>
<p>4、进而浏览器引入了onhashchange的接口，不支持的浏览器只能定时去判断hash是否改变</p>
<p>5、但这种方式对搜索引擎很不友好</p>
<p>6、twitter和google约定了使用#!xxx（即hash第一个字符为!），搜索引擎进行支持。</p>
<p>参考 ：</p>
<ol>
<li>WC3标准 <a href="https://www.w3.org/TR/XMLHttpRequest/" target="_blank" rel="external">https://www.w3.org/TR/XMLHttpRequest/</a></li>
<li>W3School <a href="https://www.w3schools.com/xml/ajax_xmlfile.asp" target="_blank" rel="external">https://www.w3schools.com/xml/ajax_xmlfile.asp</a></li>
<li>大陈小事博客<a href="http://littlewhitechen.github.io/2015/10/07/0005/" target="_blank" rel="external">http://littlewhitechen.github.io/2015/10/07/0005/</a></li>
<li>书名：Ajax实战 </li>
</ol>


            <!-- Tags -->
            


<div class="tags">
    <a href="/tags/前端/">前端</a>
</div>



            <!-- Comments -->
            <div>
                


            </div>
        </div><!-- end content -->
    </section>
</section><!-- end main -->

<!-- After footer scripts -->

<!-- jQuery -->
<script src="/js/jquery.js"></script>

<!-- Custom Code -->
<script src="/js/main.js"></script>

<!-- Gallery -->
<script src="//cdn.rawgit.com/noelboss/featherlight/1.3.5/release/featherlight.min.js" type="text/javascript" charset="utf-8"></script>

<!-- Disqus Comments -->


</body>

</html>